"""Super initial osf typings, too rough yet ..."""

from typing import Any, ClassVar, List

from typing import (overload, Iterator, Optional, Callable)
import numpy

from ouster.sdk.core import Severity
from ouster.sdk.core import BufferT, LidarScan, SensorInfo, FieldType, ScanSource


class LidarScanEncoder:
    ...

class OsfScanSource(ScanSource):
    def __init__(self, source: str, *, extrinsics: List[numpy.ndarray] = [], extrinsics_file: str = "", field_names: List[str] = [], index: bool = False) -> None:
        ...

class PngLidarScanEncoder(LidarScanEncoder):
    def __init__(self, compression_amount: int) -> None:
        ...


class Encoder:
    def __init__(self, lidar_scan_encoder: LidarScanEncoder) -> None:
        ...


class LidarScanStreamMeta:
    type_id: ClassVar[str] = ...  # read-only
    @property
    def sensor_meta_id(self) -> int: ...
    @property
    def field_types(self) -> Any: ...


class LidarScanStream:
    type_id: ClassVar[str] = ...  # read-only


class LidarSensor(MetadataEntry):
    type_id: ClassVar[str] = ...  # read-only

    @overload
    def __init__(self, arg0: SensorInfo) -> None: ...
    @overload
    def __init__(self, metadata_json: str) -> None: ...
    @property
    def info(self) -> Any: ...
    @property
    def metadata(self) -> str: ...


class Extrinsics(MetadataEntry):
    type_id: ClassVar[str] = ...  # read-only
    def __init__(self, extrinsics: numpy.ndarray, ref_meta_id: int = ..., name: str = ...) -> None: ...
    @property
    def extrinsics(self) -> numpy.ndarray: ...
    @property
    def ref_meta_id(self) -> int: ...
    @property
    def name(self) -> str: ...


class MessageRef:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def decode(self) -> object: ...
    @overload
    def decode(self, fields: Optional[List[str]]) -> object: ...
    def of(self, arg0: object) -> bool: ...
    @property
    def id(self) -> int: ...
    @property
    def ts(self) -> int: ...
    @property
    def buffer(self) -> BufferT: ...



class MetadataEntry:
    def __init__(self) -> None: ...
    @classmethod
    def from_buffer(cls, arg0: List[int], arg1: str) -> MetadataEntry: ...
    def of(self, arg0: object) -> bool: ...
    @property
    def buffer(self) -> List[int]: ...
    @property
    def id(self) -> int: ...
    @property
    def static_type(self) -> str: ...
    @property
    def type(self) -> str: ...


class MetadataStore:
    def __init__(self) -> None: ...
    def find(self, *args, **kwargs) -> Any: ...
    def get(self, *args, **kwargs) -> Any: ...
    def items(self) -> Iterator: ...
    def __getitem__(self, index) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...


class Reader:
    def __init__(self, arg0: str, error_handler: Optional[Callable[[Severity, str], None]] = None) -> None: ...
    def chunks(self) -> Iterator: ...
    @overload
    def messages(self) -> Iterator: ...
    @overload
    def messages(self, start_ts: int, end_ts: int) -> Iterator: ...
    @overload
    def messages(self, stream_ids: List[int]) -> Iterator: ...
    @overload
    def messages(self, stream_ids: List[int], start_ts: int, end_ts: int) -> Iterator: ...
    @property
    def end_ts(self) -> int: ...
    @property
    def metadata_id(self) -> str: ...
    @property
    def meta_store(self) -> Any: ...
    @property
    def start_ts(self) -> int: ...
    @property
    def has_stream_info(self) -> bool: ...
    @property
    def has_message_idx(self) -> bool: ...
    @property
    def has_timestamp_idx(self) -> bool: ...
    def ts_by_message_idx(self, stream_id: int, msg_idx: int) -> int: ...
    @property
    def version(self) -> int: ...


class StreamStats:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def end_ts(self) -> int: ...
    @property
    def message_avg_size(self) -> int: ...
    @property
    def message_count(self) -> int: ...
    @property
    def start_ts(self) -> int: ...
    @property
    def stream_id(self) -> int: ...


class StreamingInfo(MetadataEntry):
    type_id: ClassVar[str] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def chunks_info(self) -> Iterator: ...
    @property
    def stream_stats(self) -> Iterator: ...


class Writer:
    @overload
    def __init__(self, file_name: str, chunk_size: int = ...) -> None: ...
    @overload
    def __init__(self, filename: str, info: SensorInfo,
                 fields_to_write: List[str] = ..., chunk_size: int = ..., encoder: Encoder = ...) -> None: ...
    @overload
    def __init__(self, filename: str, info: List[SensorInfo],
                 fields_to_write: List[str] = ..., chunk_size: int = ..., encoder: Encoder = ...) -> None: ...
    @overload
    def save(self, stream_id: int, scan: LidarScan) -> None: ...
    @overload
    def save(self, stream_id: int, scan: LidarScan, ts: int) -> None: ...
    @overload
    def save(self, scan: List[LidarScan]) -> None: ...
    def add_sensor(self, info: SensorInfo, fields_to_write: List[str] = ...) -> int: ...
    def add_metadata(self, arg0: object) -> int: ...
    def save_message(self, stream_id: int, receive_ts: int, sensor_ts: int, buffer: BufferT) -> int: ...
    @overload
    def sensor_info(self) -> List[SensorInfo]: ...
    @overload
    def sensor_info(self, stream_id: int) -> SensorInfo: ...
    def sensor_info_count(self) -> int: ...
    def filename(self) -> str: ...
    def metadata_id(self) -> str: ...
    def set_metadata_id(self, id: str) -> None: ...
    @property
    def meta_store(self) -> MetadataStore: ...
    def close(self) -> None: ...
    def is_closed(self) -> bool: ...
    def __enter__(self) -> Writer: ...
    def __exit__(*args) -> None: ...


class FutureWrapper:
    def get(self) -> None:
        ...


class AsyncWriter:
    def __init__(self, filename: str, info: List[SensorInfo],
                 fields_to_write: List[str] = ..., chunk_size: int = ..., encoder: Encoder = ...) -> None: ...
    @overload
    def save(self, stream_id: int, scan: LidarScan) -> FutureWrapper: ...
    @overload
    def save(self, stream_id: int, scan: LidarScan, ts: int) -> FutureWrapper: ...
    @overload
    def save(self, scan: List[LidarScan]) -> List[FutureWrapper]: ...
    def close(self) -> None: ...
    def __enter__(self) -> AsyncWriter: ...
    def __exit__(*args) -> None: ...


def slice_and_cast(lidar_scan: LidarScan, field_types = ...) -> LidarScan: ...

def init_logger(log_level: str,
                log_file_path: str = ...,
                rotating: bool = ...,
                max_size_in_bytes: int = ...,
                max_files: int = ...) -> bool:
    ...

def dump_metadata(file: str, full: bool = ...) -> str: ...
def parse_and_print(file: str, with_decoding: bool = ...) -> None: ...

def backup_osf_file_metablob(file: str, backup_file_name: str) -> None: ...
def restore_osf_file_metablob(file: str, backup_file_name: str) -> None: ...
def osf_file_modify_metadata(file: str, new_metadata: List[SensorInfo]) -> int: ...
