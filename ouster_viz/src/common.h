#pragma once

#include <GL/glew.h>

#include <atomic>
#include <iostream>
#include <memory>
#include <mutex>
#include <string>

namespace ouster {
namespace viz {
namespace impl {

extern int window_width;
extern int window_height;

inline void error_callback(int error, const char* description) {
    std::cerr << "error " << error << std::endl;
    std::cerr << description << std::endl;
}

/**
 * load and compile GLSL shaders
 *
 * @param vertex_shader_code code of vertex shader
 * @param fragment_shader_code code of fragment shader
 * @return handle to program_id
 */
GLuint load_shaders(const std::string& vertex_shader_code,
                    const std::string& fragment_shader_code);

/**
 * load a texture from an array of GLfloat or equivalent
 * such as float[n][3]
 *
 * @param texture array of at least size width * height * elements_per_texel
 *                where elements per texel is 3 for GL_RGB and 1 for GL_RED
 * @param width   width of texture in texels
 * @param height  height of texture in texels
 * @param texture_id handle generated by glGenTextures
 * @param internal_format internal format, e.g. GL_RGB or GL_RGB32F
 * @param format  format, e.g. GL_RGB or GL_RED
 */
template <class F>
void load_texture(const F& texture, const size_t width, const size_t height,
                  const GLuint texture_id,
                  const GLenum internal_format = GL_RGB,
                  const GLenum format = GL_RGB) {
    glBindTexture(GL_TEXTURE_2D, texture_id);

    // we have only 1 level, so we override base/max levels
    // https://www.khronos.org/opengl/wiki/Common_Mistakes#Creating_a_complete_texture
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, height, 0, format,
                 GL_FLOAT, texture);
}

/**
 * The point vertex shader supports transforming the point cloud by an array of
 * transformations.
 *
 * @param xyz            XYZ point before it was multiplied by range.
 *                       Corresponds to the "xyzlut" used by LidarScan.
 *
 * @param range          Range of each point.
 *
 * @param key            Key for colouring each point for aesthetic reasons.
 *
 * @param trans_index    Index of which of the transformations to use for this
 *                       point. Normalized between 0 and 1. (0 being the first
 *                       1 being the last).
 *
 * @param model          Extrinsic calibration of the lidar.
 *
 * @param transformation The w transformations are stored as a w x 4 texture.
 *                       Each column of the texture corresponds one 4 x 4
 *                       transformation matrix, where the four pixels' rgb
 *                       values correspond to four columns (3 rotation 1
 *                       translation)
 *
 * @param proj_view      Camera view matrix controlled by the visualizer.
 */
static const std::string point_vertex_shader_code =
    R"SHADER(
            #version 120

            attribute vec3 xyz;
            attribute vec3 offset;
            attribute float range;
            attribute float key;
            attribute vec4 mask;
            attribute float trans_index;

            uniform sampler2D transformation;
            uniform mat4 model;
            uniform mat4 proj_view;

            varying float vcolor;
            varying vec4 overlay_rgba;
            void main(){
                vec4 local_point = range > 0
                                   ? model * vec4(xyz * range + offset, 1.0)
                                   : vec4(0, 0, 0, 1.0);
                // Here, we get the four columns of the transformation.
                // Since this version of GLSL doesn't have texel fetch,
                // we use texture2D instead. Numbers are chosen to index
                // the middle of each pixel.
                // |     r0     |     r1     |     r2     |     t     |
                // 0   0.125  0.25  0.375   0.5  0.625  0.75  0.875   1
                vec4 r0 = texture2D(transformation, vec2(trans_index, 0.125));
                vec4 r1 = texture2D(transformation, vec2(trans_index, 0.375));
                vec4 r2 = texture2D(transformation, vec2(trans_index, 0.625));
                vec4 t = texture2D(transformation, vec2(trans_index, 0.875));
                mat4 car_pose = mat4(
                    r0.x, r0.y, r0.z, 0,
                    r1.x, r1.y, r1.z, 0,
                    r2.x, r2.y, r2.z, 0,
                     t.x,  t.y,  t.z, 1
                );

                gl_Position = proj_view * car_pose * local_point;
                vcolor = sqrt(key);
                overlay_rgba = mask;
            })SHADER";
static const std::string point_fragment_shader_code =
    R"SHADER(
            #version 120
            varying float vcolor;
            varying vec4 overlay_rgba;
            uniform sampler2D palette;
            void main() {
                gl_FragColor = vec4(texture2D(palette, vec2(vcolor, 1)).xyz * (1.0 - overlay_rgba.w)
                              + overlay_rgba.xyz * overlay_rgba.w, 1);
            })SHADER";
static const std::string ring_vertex_shader_code =
    R"SHADER(
            #version 120
            attribute vec3 ring_xyz;
            uniform float ring_range;
            uniform mat4 proj_view;
            void main(){
                gl_Position = proj_view * vec4(ring_xyz * ring_range, 1.0);
                gl_Position.z = gl_Position.w;
            })SHADER";
static const std::string ring_fragment_shader_code =
    R"SHADER(
            #version 120
            void main() {
                gl_FragColor = vec4(0.15, 0.15, 0.15, 1);
            })SHADER";
static const std::string cuboid_vertex_shader_code =
    R"SHADER(
            #version 120
            attribute vec3 cuboid_xyz;
            uniform vec4 cuboid_rgba;
            uniform mat4 pose;
            uniform mat4 proj_view;
            varying vec4 rgba;
            void main(){
                gl_Position = proj_view * pose * vec4(cuboid_xyz, 1.0);
                rgba = cuboid_rgba;
            })SHADER";
static const std::string cuboid_fragment_shader_code =
    R"SHADER(
            #version 120
            varying vec4 rgba;
            void main() {
                gl_FragColor = rgba;
            })SHADER";
static const std::string image_vertex_shader_code =
    R"SHADER(
            #version 120
            attribute vec2 vertex;
            attribute vec2 vertex_uv;
            varying vec2 uv;
            void main() {
                uv = vertex_uv;
                gl_Position = vec4(vertex, -1, 1);
            })SHADER";
static const std::string image_fragment_shader_code =
    R"SHADER(
            #version 120
            varying vec2 uv;
            uniform sampler2D image;
            uniform sampler2D mask;
            void main() {
                vec4 m = texture2D(mask, uv);
                float a = m.a;
                float r = sqrt(texture2D(image, uv).r) * (1.0 - a);
                gl_FragColor = vec4(vec3(r, r, r) + m.rgb * a, 1.0);
            })SHADER";

/**
 * struct containing handles to variables in GLSL shader program compiled from
 * point_vertex_shader_code and point_fragment_shader_code
 */
struct CloudIds {
    GLuint xyz_id, off_id, range_id, key_id, mask_id, model_id, proj_view_id,
        palette_id, transformation_id, trans_index_id;
    CloudIds() {}

    /**
     * constructor
     * @param point_program_id handle to GLSL shader program compiled from
     * point_vertex_shader_code and point_fragment_shader_code
     */
    explicit CloudIds(GLuint point_program_id)
        : xyz_id(glGetAttribLocation(point_program_id, "xyz")),
          off_id(glGetAttribLocation(point_program_id, "offset")),
          range_id(glGetAttribLocation(point_program_id, "range")),
          key_id(glGetAttribLocation(point_program_id, "key")),
          mask_id(glGetAttribLocation(point_program_id, "mask")),
          model_id(glGetUniformLocation(point_program_id, "model")),
          proj_view_id(glGetUniformLocation(point_program_id, "proj_view")),
          palette_id(glGetUniformLocation(point_program_id, "palette")),
          transformation_id(
              glGetUniformLocation(point_program_id, "transformation")),
          trans_index_id(glGetAttribLocation(point_program_id, "trans_index")) {
    }
};

/**
 * Class to maintain a double buffer, so that you can keep writing data
 * without affecting what is being drawn.
 */
template <class T>
class DoubleBuffer {
    std::mutex buffer_mutex;

   public:
    std::unique_ptr<T> write;
    std::unique_ptr<T> read;
    std::atomic_bool enabled;

    /**
     * Constructor
     *
     * @param args arguments for the T::T() constructor
     */
    template <typename... Args>
    explicit DoubleBuffer(Args&&... args)
        : write(new T(std::forward<Args>(args)...)),
          read(new T(*write)),
          enabled(true) {}

    /**
     * calls draw on the readable element in the double buffer
     *
     * @param args arguments for T::draw
     */
    template <typename... Args>
    void draw(Args&&... args) {
        std::lock_guard<std::mutex> guard(buffer_mutex);
        read->draw(std::forward<Args>(args)...);
    }

    /**
     * swaps the readable and writable part of the double buffer, i.e.
     * after all relevant data have been written
     */
    void swap() {
        std::lock_guard<std::mutex> guard(buffer_mutex);
        std::swap(read, write);
    }
};

}  // namespace impl
}  // namespace viz
}  // namespace ouster
