#pragma once

#include <cstddef>
#include <vector>

#include "ouster/cartesian.h"
#include "ouster/lidar_scan.h"
#include "ouster/typedefs.h"
#include "ouster/visibility.h"

namespace ouster {
namespace sdk {
namespace core {
// Forward declaration
class SensorInfo;

template <typename T>
class XYZLutT;
/**
 * Alias for XYZLutT using `double` precision.
 */
using XYZLut = XYZLutT<double>;

/**
 * Generate a set of lookup tables useful for computing Cartesian coordinates
 * from ranges.
 *
 * The lookup tables are:
 * - direction: a matrix of unit vectors pointing radially outwards.
 * - offset: a matrix of offsets dependent on beam origin distance from lidar
 *           origin.
 *
 * Each table is an n x 3 array of doubles stored in column-major order where
 * each row corresponds to the nth point in a lidar scan, with 0 <= n < h*w.
 *
 * Projections to XYZ made with this XYZLut will be in the coordinate frame
 * defined by transform*beam_to_lidar_transform.
 *
 * @param[in] w number of columns in the lidar scan. e.g. 512, 1024, or 2048.
 * @param[in] h number of rows in the lidar scan.
 * @param[in] range_unit the unit, in meters, of the range,  e.g.
 * ouster::sdk::core::range_unit.
 * @param[in] beam_to_lidar_transform transform between beams and
 * lidar origin. Translation portion is in millimeters.
 * @param[in] transform additional transformation to apply to resulting points.
 * @param[in] azimuth_angles_deg azimuth offsets in degrees for each of h beams.
 * @param[in] altitude_angles_deg altitude in degrees for each of h beams.
 *
 * @return xyz direction and offset vectors for each point in the lidar scan.
 */
OUSTER_API_FUNCTION
XYZLut make_xyz_lut(size_t w, size_t h, double range_unit,
                    const mat4d& beam_to_lidar_transform,
                    const mat4d& transform,
                    const std::vector<double>& azimuth_angles_deg,
                    const std::vector<double>& altitude_angles_deg);

/**
 * Convenient overload that uses parameters from the supplied SensorInfo.
 * Projections to XYZ made with this XYZLut will be in the sensor coordinate
 * frame defined in the sensor documentation unless use_extrinics is true.
 * Then the projections will be in the coordinate frame defined by the provided
 * extrinsics in the metadata.
 *
 * @param[in] sensor metadata returned from the client.
 * @param[in] use_extrinsics if true, applies the ``sensor.extrinsic`` transform
 *                           to the resulting "sensor frame" coordinates
 *
 * @return xyz direction and offset vectors for each point in the lidar scan.
 */
OUSTER_API_FUNCTION
XYZLut make_xyz_lut(const SensorInfo& sensor, bool use_extrinsics);

/** Lookup table of beam directions and offsets. */
template <typename T>
class XYZLutT {
   public:
    /**
     * Unit direction vectors from the sensor for each pixel.
     */
    ArrayX3R<T> direction;
    /**
     * Offset vectors for each pixel, typically representing per-pixel
     * translations.
     *
     * Combined with direction and range to compute 3D coordinates.
     */
    ArrayX3R<T> offset;

    // Add this to make XYZLut<double> and XYZLut<float> friends to cast
    template <typename>
    friend class XYZLutT;

    /**
     * Construct an XYZ lookup table using the provided sensor information.
     *
     * @param[in] sensor Sensor metadata including intrinsics and resolution.
     * @param[in] use_extrinsics Whether to apply extrinsic calibration.
     */
    XYZLutT(const SensorInfo& sensor, bool use_extrinsics) {
        auto res = make_xyz_lut(sensor, use_extrinsics);
        *this = res.cast<T>();
    }

    XYZLutT() = default;

    PointCloudXYZ<T> operator()(
        const Eigen::Ref<const img_t<uint32_t>>& range) const {
        PointCloudXYZ<T> points(range.rows() * range.cols(), 3);
        cartesianT<T>(points, range, direction, offset);
        return points;
    }

    PointCloudXYZ<T> operator()(const LidarScan& scan) const {
        Eigen::Ref<const img_t<uint32_t>> range =
            scan.field<uint32_t>(ChanField::RANGE);
        PointCloudXYZ<T> points(range.rows() * range.cols(), 3);
        cartesianT<T>(points, range, direction, offset);
        return points;
    }

   private:
    template <typename NewT>
    XYZLutT<NewT> cast() const {
        XYZLutT<NewT> result;
        result.direction = direction.template cast<NewT>();
        result.offset = offset.template cast<NewT>();
        return result;
    }
};

/** \defgroup ouster_client_lidar_scan_cartesian Ouster Client lidar_scan.h
 * XYZLut related items.
 * @{
 */
/**
 * Convert LidarScan to Cartesian points.
 *
 * @param[in] scan a LidarScan.
 * @param[in] lut lookup tables generated by make_xyz_lut.
 *
 * @return Cartesian points where ith row is a 3D point which corresponds
 *         to ith pixel in LidarScan where i = row * w + col.
 */
OUSTER_API_FUNCTION
PointCloudXYZd cartesian(const LidarScan& scan, const XYZLut& lut);

/**
 * Convert a staggered range image to Cartesian points.
 *
 * @param[in] range a range image in the same format as the RANGE field of a
 * LidarScan.
 * @param[in] lut lookup tables generated by make_xyz_lut.
 *
 * @return Cartesian points where ith row is a 3D point which corresponds
 *         to ith pixel in LidarScan where i = row * w + col.
 */
OUSTER_API_FUNCTION
PointCloudXYZd cartesian(const Eigen::Ref<const img_t<uint32_t>>& range,
                         const XYZLut& lut);
/** @}*/

}  // namespace core
}  // namespace sdk
}  // namespace ouster
